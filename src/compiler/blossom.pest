//! Blossom Language Grammar
//! A modern, type-safe programming language with first-class error handling

// ========= Core Program Structure =========

// A Blossom source file must:
// 1. Start with @module declaration
// 2. Follow with @import or @use statements
// 3. Continue with type definitions and function declarations
BLOSSOM = {
    SOI ~ MODULE_DECLARATION ~ (IMPORT_DECLARATION | USING_DECLARATION)* ~ (TYPE_DEFINITION | FUNCTION_DEFINITION | VARIABLE_DEFINITION)* ~ EOI
}

// ========= Core Language Elements =========

// Skip whitespace and comments during parsing
WHITESPACE = _{ " " | "\t" | NEWLINE }
NEWLINE    = _{ "\r\n" | "\n" | "\r" }

// Comments support both single-line and multi-line styles
COMMENT = _{
    ("//" ~ (!NEWLINE ~ ANY)*)
  | // Single-line comment
  ("/*" ~ (!"*/" ~ ANY)* ~ "*/") // Multi-line comment
}

// Valid identifier: starts with letter, followed by letters/numbers/_
IDENTIFIER = @{ ASCII_ALPHA ~ (ASCII_ALPHANUMERIC | "_")* }

// ========= Decorators and Annotations =========

// Decorators modify the behavior or visibility of declarations
// Examples: @public, @pure
DECORATOR = {
    "@public"
  | "@private"
  | "@pure"
}

DECORATOR_LIST = { DECORATOR* }

// ========= Module System =========

// Module path identifier
// Example: Standard.IO
MODULE_PATH = { IDENTIFIER ~ ("." ~ IDENTIFIER)* }

// Module declaration defines the current module's name
// Example: @module GameEngine
MODULE_DECLARATION = { "@module" ~ IDENTIFIER }

// Import brings in external modules, optionally with aliases
// Examples:
// @import HTTP
// @import Logger as L
IMPORT_DECLARATION = {
    "@import" ~ MODULE_PATH ~ ("as" ~ IDENTIFIER)?
}

// Using imports add symbols directly to current scope
// Example: @using Standard.IO
USING_DECLARATION = { "@using" ~ MODULE_PATH }

// ========= Types and Type Definitions =========

// Built-in primitive types
PRIMITIVE_TYPE = {
    "None"
  | "Integer"
  | "Float"
  | "String"
  | "Boolean"
  | "Binary"
}

// Type definition using := operator
// Examples:
// Point := (Float, Float)
// Result := (Success, Error)
TYPE_DEFINITION = {
    DECORATOR_LIST ~ IDENTIFIER ~ ":=" ~ BASE_TYPE ~ (("->" ~ CONSTRAINT_EXPRESSION) | WHERE_CLAUSE)?
}

// Types can be constrained using where clauses
WHERE_CLAUSE = {
    "where" ~ CONSTRAINT_EXPRESSION ~ ("," ~ CONSTRAINT_EXPRESSION)*
}

// Base types without constraints
BASE_TYPE = {
    ENUM_DEFINITION
  | COLLECTION_TYPE
  | OPTIONAL_TYPE
  | PRIMITIVE_TYPE
}

// Collections: Lists, Tuples, Records
COLLECTION_TYPE = {
    LIST_TYPE
  | TUPLE_TYPE
  | RECORD_TYPE
}

// ========= Collection Types =========

// List type definition
// Example: List(Integer)
LIST_TYPE = { "List" ~ "(" ~ PRIMITIVE_TYPE ~ ")" }

// Tuple type definition
// Example: (Float, Float)
TUPLE_TYPE = {
    "(" ~ PRIMITIVE_TYPE ~ ("," ~ PRIMITIVE_TYPE)* ~ ")"
}

// Record type definition
// Example: { name: String, age: Integer }
RECORD_FIELD = { IDENTIFIER ~ ":" ~ PRIMITIVE_TYPE }
RECORD_TYPE  = {
    "{" ~ RECORD_FIELD ~ ("," ~ RECORD_FIELD)* ~ "}"
}

// ========= Enum Types =========

// Enum variant naming follows PascalCase convention
ENUM_VARIANT = @{ ASCII_ALPHA_UPPER ~ (ASCII_ALPHANUMERIC | "_")* }

// Enum definition
// Example: (North, South, East, West)
ENUM_DEFINITION = {
    "(" ~ ENUM_VARIANT ~ ("," ~ ENUM_VARIANT)* ~ ")"
}

// ========= Optional Types =========

// Optional type wraps another type
// Example: Optional(Integer)
OPTIONAL_TYPE = {
    "Optional" ~ "(" ~ (PRIMITIVE_TYPE | LIST_TYPE | TUPLE_TYPE | RECORD_TYPE) ~ ")"
}

// ========= Function Definitions =========

// Complete function definition with decorators, params, return type, errors
FUNCTION_DEFINITION = {
    DECORATOR_LIST ~ IDENTIFIER ~ (PARAMETERS_MULTILINE ~ (":" ~ PRIMITIVE_TYPE)? ~ ERROR_SPEC? ~ "->" | "->") ~ BLOCK
}

// Multi-line parameter support
PARAMETERS_MULTILINE = {
    "(" ~ WHITESPACE* ~ (PARAMETER ~ ("," ~ WHITESPACE* ~ PARAMETER)* ~ ","?)? ~ WHITESPACE* ~ ")"
}

PARAMETER = {
    WHITESPACE* ~ IDENTIFIER ~ ":" ~ PRIMITIVE_TYPE ~ WHITESPACE*
}

// ========= Error Handling =========

// Error specification for functions
// Can be single error or tuple of errors
ERROR_SPEC = {
    "!" ~ (IDENTIFIER | ERROR_TUPLE)
}

ERROR_TUPLE = {
    "(" ~ IDENTIFIER ~ ("," ~ IDENTIFIER)* ~ ")"
}

// Throw expression for error handling
THROW_EXPRESSION = {
    "throw" ~ IDENTIFIER ~ "." ~ ENUM_VARIANT
}

// ========= Expressions =========

// Expressions represent computations that produce values
// Core expression types include:
// - Literals (42, "hello", True)
// - Variables (myVar, counter)
// - Function calls (Calculate(x))
// - Operations (a + b, !isDone)
// - Pattern matching (match x -> { ... })

// Base expressions (non-recursive)
ATOM = {
    LITERAL
  | IDENTIFIER
  | MATCH_EXPRESSION
  | THROW_EXPRESSION
  | "(" ~ EXPRESSION ~ ")"
}

// Main expression rule using pratt parser for operator precedence
EXPRESSION = {
    ATOM ~ (INFIX_OPERATOR ~ ATOM)*
}

// ========= Operators =========

// All operators that can appear between expressions
INFIX_OPERATOR = _{
    ARITHMETIC_OPERATOR
  | LOGICAL_OPERATOR
  | COMPARISON_OPERATOR
  | PIPELINE_OPERATOR
  | ERROR_HANDLER_OPERATOR
}

// Arithmetic: +, -, *, /, %
ARITHMETIC_OPERATOR = {
    "+"
  | "-"
  | "*"
  | "/"
  | "%"
}

// Logical: &, |, !
LOGICAL_OPERATOR = {
    "&"
  | "|"
  | "!"
}

// Comparison: ==, !=, >, <, >=, <=
COMPARISON_OPERATOR = {
    "=="
  | "!="
  | ">="
  | "<="
  | ">"
  | "<"
}

// Pipeline operators for chaining and error handling
PIPELINE_OPERATOR      = { "|>" }
ERROR_HANDLER_OPERATOR = { "!>" }

// ========= Literals =========

// Base literals (non-recursive)
BASE_LITERAL = {
    INTEGER
  | FLOAT
  | STRING
  | BOOLEAN
  | BINARY_LITERAL
  | OPTIONAL_VALUE
}

// Collection literals
COLLECTION_LITERAL = {
    ENUM_VALUE
  | TUPLE_VALUE
  | LIST_VALUE
  | RECORD_VALUE
}

// Combined literal rule
LITERAL = {
    BASE_LITERAL
  | COLLECTION_LITERAL
}

// String literal (e.g., "hello", "path/to/file")
STRING = @{
    STRING_TEMPLATE
  | ("\"" ~ (!"\"" ~ ANY)* ~ "\"")
}

// Integer with optional underscores (e.g., 1_000_000)
INTEGER = @{ "-"? ~ ASCII_DIGIT+ ~ ("_" ~ ASCII_DIGIT+)* }

// Float with optional scientific notation
FLOAT = @{
    "-"? ~ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ ~ ("e" ~ ("+" | "-")? ~ ASCII_DIGIT+)?
}

// Binary numbers and byte arrays
BINARY_DIGIT  =  { "0" | "1" }
BINARY_NUMBER = @{ "0b" ~ BINARY_DIGIT+ }
HEX_NUMBER    = @{ "0x" ~ ASCII_HEX_DIGIT+ }
BYTES         = @{ "#[" ~ ASCII_HEX_DIGIT{2} ~ (" " ~ ASCII_HEX_DIGIT{2})* ~ "]" }

BINARY_LITERAL = {
    BINARY_NUMBER
  | HEX_NUMBER
  | BYTES
}

// Boolean literals
BOOLEAN = { "True" | "False" }

// Optional values
OPTIONAL_VALUE = {
    "None"
  | "Some" ~ "(" ~ LITERAL ~ ")"
}

// ========= Collection Values =========

// Enum value (e.g., Direction.North)
ENUM_VALUE = {
    IDENTIFIER ~ "." ~ ENUM_VARIANT
}

// Tuple value (e.g., (0.0, 0.0))
TUPLE_VALUE = {
    "(" ~ LITERAL ~ ("," ~ LITERAL)* ~ ")"
}

// List value with optional spread operator
LIST_VALUE = {
    "[" ~ (SPREAD_OPERATOR | LITERAL)? ~ ("," ~ (SPREAD_OPERATOR | LITERAL))* ~ "]"
}

// Record value with optional spread
RECORD_FIELD_VALUE = {
    IDENTIFIER ~ ":" ~ LITERAL
}

RECORD_VALUE = {
    "{" ~ (SPREAD_OPERATOR | RECORD_FIELD_VALUE) ~ ("," ~ (SPREAD_OPERATOR | RECORD_FIELD_VALUE))* ~ "}"
}

// Spread operator for collections
SPREAD_OPERATOR = { "..." ~ IDENTIFIER }

// ========= String Templates =========

// String template expression (e.g., "Hello, {{name}}!")
STRING_TEMPLATE_EXPR = {
    "{{" ~ (!("}}" | "{{") ~ ANY)* ~ "}}"
}

STRING_TEMPLATE = @{
    "\"" ~ (STRING_TEMPLATE_EXPR | (!"\"" ~ ANY))* ~ "\""
}

// ========= Pattern Matching =========

// Patterns that can appear in match expressions
MATCH_PATTERN = {
    LITERAL
  | // literal pattern
  "_"
  | // wildcard pattern
  (IDENTIFIER ~ ":" ~ PRIMITIVE_TYPE)
  | // binding pattern
  "(" ~ MATCH_PATTERN ~ ("," ~ MATCH_PATTERN)* ~ ")" // tuple pattern
}

// Match arms (pattern -> expression)
MATCH_ARM = {
    MATCH_PATTERN ~ "->" ~ (EXPRESSION | BLOCK)
}

// Complete match expression
MATCH_EXPRESSION = {
    "match" ~ EXPRESSION ~ "->" ~ "{" ~ MATCH_ARM ~ ("," ~ MATCH_ARM)* ~ "}"
}

// ========= Variables and Blocks =========

// Variable definition with type and optional initialization
VARIABLE_DEFINITION = {
    IDENTIFIER ~ ":" ~ (PRIMITIVE_TYPE | OPTIONAL_TYPE) ~ ("=" ~ (LITERAL | "None"))?
}

// A block is a sequence of statements with a final expression
BLOCK = {
    "{" ~ (VARIABLE_DEFINITION | EXPRESSION)* ~ EXPRESSION? ~ "}"
}

// ========= Constraints =========

// Constraint functions for type refinements
CONSTRAINT_FUNCTION = {
    IDENTIFIER ~ ("(" ~ LITERAL ~ ")")?
}

// Combined constraint expression
CONSTRAINT_EXPRESSION = {
    CONSTRAINT_FUNCTION ~ (LOGICAL_OPERATOR ~ CONSTRAINT_FUNCTION)*
}
